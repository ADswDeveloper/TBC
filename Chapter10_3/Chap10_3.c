// Chap 10_3.c : 
// 강의 요약 : 포인터 산술연산 -> 상식적인 산술연산과 다르게 작용. 주소값이라는 특징때문에 가능한 연산, 불가능한 연산, 예외적인 연산이 존재.
// 포인터 연산 -> 자료형 크기만큼 건너뜀.
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <limits.h>

int main()
{
    // 포인터 산술연산 -> 상식적인 산술연산과 다르게 작용. 
    // 1, 포인터++
    // 2, 포인터 + 포인터 : 불가. 영희 주소와 철수 주소를 더해봤자 의미없는 주소가 나옴.
    // 3, 포인터 - 포인터 : 가능. 철수가 301호에 살고 303호에 살면, 303-301=2, 두 집 차이라는 의미.

    {
        long long* ptr = 0; // 보통 null로 초기화하는게 좋음. 리터럴을 대입해서 사용하지도 않음. *ptr -> 간접 접근 불가. 
        printf("%p %lld\n", ptr, (long long)ptr); // ptr을 long long으로 캐스팅 하는 이유는, 64비트의 경우 주소가 8바이트라서.. x86은 사실 상관없음.

        ptr += 1; // 포인터에 1을 더하는 것 -> 자료형 사이즈만큼 더해주는 것. 
        // 포인터 산술연산은 진짜 1을 더하는 것이 아니라, 자료형 사이즈 만큼 연산하는 것.
        printf("%p %lld\n", ptr, (long long)ptr);

        void* voidptr = 0;
        //voidptr += 1; // void 포인터는 자료형 크기가 없음.. 포인터 연산 불가.
    }

    // 포인터끼리 연산
    // 포인터 - 포인터 : 주어진 자료형에서 인덱스 차이가 얼마 나는가. 단순히 주소값을 빼주는게 아니라, 자료형으로 자동으로 나눠서, 몇 칸 차이가 있는지도 알려줌.
    {
        double arr[10];
        double* ptr1 = &arr[0], * ptr2 = &arr[2];
        
        //int q = ptr1 + ptr2; // 불가능.
        int i = ptr1 - ptr2; // double형 포인터니까 8바이트씩 2칸 떨어져있으니 16이 나와야 할 것 같지만, 2가 나옴. 자동으로 double 크기로 나눠서 출력.
        // 즉, 몇 칸 만큼 떨어져있는지, 인덱스가 얼마나 차이가 나는지 구해줌. 
        
        printf("%lld %lld %d", (long long)ptr1, (long long)ptr2, i); // i -> 2. 
    }
    
    

    return 0;
}

